<!DOCTYPE html>
<html lang="zh-CN">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCB螺旋线圈生成器</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Segoe UI', Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background: #f0f2f5;
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        margin-bottom: 30px;
        padding: 20px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: #1a73e8;
        margin-bottom: 10px;
        font-size: 2.2em;
      }

      .subtitle {
        color: #666;
        font-size: 1em;
      }

      .content {
        display: grid;
        grid-template-columns: 350px 1fr;
        gap: 20px;
        margin-bottom: 30px;
      }

      @media (max-width: 1024px) {
        .content {
          grid-template-columns: 1fr;
        }
      }

      .control-panel {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .control-group {
        margin-bottom: 25px;
      }

      .control-group h3 {
        color: #1a73e8;
        margin-bottom: 15px;
        padding-bottom: 5px;
        border-bottom: 2px solid #e8eaed;
        font-size: 1.1em;
      }

      .parameter-row {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
        color: #333;
        font-size: 0.95em;
      }

      .input-with-unit {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      input[type="number"] {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        transition: border 0.3s;
      }

      input[type="number"]:focus {
        outline: none;
        border-color: #1a73e8;
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
      }

      .unit {
        color: #666;
        font-size: 0.9em;
        min-width: 40px;
      }

      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .checkbox-group label {
        margin-bottom: 0;
        cursor: pointer;
      }

      input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
      }

      .preview-container {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
      }

      .canvas-wrapper {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background: white;
        border-radius: 4px;
        overflow: hidden;
        border: 1px solid #e8eaed;
        min-height: 500px;
        position: relative;
      }

      canvas {
        display: block;
      }

      .controls {
        display: flex;
        gap: 10px;
        margin-top: 15px;
        flex-wrap: wrap;
      }

      button {
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        flex: 1;
        min-width: 120px;
      }

      .btn-export-svg {
        background: #34a853;
        color: white;
      }

      .btn-export-png {
        background: #1a73e8;
        color: white;
      }

      .btn-generate {
        background: #fbbc05;
        color: white;
      }

      button:hover {
        opacity: 0.9;
        transform: translateY(-1px);
      }

      button:active {
        transform: translateY(0);
      }

      .coordinate-info {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        opacity: 0.8;
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #666;
        font-size: 14px;
      }

      .status-bar {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
      }

      .info-panel {
        background: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .info-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
      }

      .info-item {
        padding: 10px;
        background: #f8f9fa;
        border-radius: 4px;
      }

      .info-item h4 {
        color: #666;
        margin-bottom: 5px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .info-item p {
        color: #333;
        font-size: 14px;
        font-weight: 600;
      }

      footer {
        text-align: center;
        margin-top: 20px;
        padding: 15px;
        color: #666;
        font-size: 0.85em;
      }

      .help-text {
        color: #666;
        font-size: 0.85em;
        margin-top: 5px;
        font-style: italic;
      }

      .canvas-border {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(45deg, #f5f5f5 25%, transparent 25%),
          linear-gradient(-45deg, #f5f5f5 25%, transparent 25%),
          linear-gradient(45deg, transparent 75%, #f5f5f5 75%),
          linear-gradient(-45deg, transparent 75%, #f5f5f5 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <header>
        <h1>PCB螺旋线圈生成器</h1>
        <p class="subtitle">生成平滑的螺旋线圈，支持SVG/PNG导出，适用于PCB布线 <a style="text-decoration: none;" href="https://webench.ti.com/wb5/LDC/#/spirals" target="_blank">TI线圈设计工具</a></p>
      </header>

      <div class="content">
        <div class="control-panel">
          <div class="control-group">
            <h3>几何参数</h3>
            <div class="parameter-row">
              <label for="innerRadius">内径 (r):</label>
              <div class="input-with-unit">
                <input type="number" id="innerRadius" min="0.1" max="100" step="0.1" value="3.5">
                <span class="unit">mm</span>
              </div>
              <div class="help-text">线圈中心孔的半径</div>
            </div>
            <div class="parameter-row">
              <label for="spacing">线间距 (d):</label>
              <div class="input-with-unit">
                <input type="number" id="spacing" min="0.1" max="10" step="0.01" value="0.26">
                <span class="unit">mm</span>
              </div>
              <div class="help-text">相邻导线中心之间的距离</div>
            </div>
            <div class="parameter-row">
              <label for="wireWidth">线宽 (w):</label>
              <div class="input-with-unit">
                <input type="number" id="wireWidth" min="0.1" max="5" step="0.01" value="0.15">
                <span class="unit">mm</span>
              </div>
              <div class="help-text">导线的宽度</div>
            </div>
            <div class="parameter-row">
              <label for="turns">圈数 (N):</label>
              <div class="input-with-unit">
                <input type="number" id="turns" min="1" max="50" step="0.5" value="17">
                <span class="unit">圈</span>
              </div>
            </div>
          </div>

          <div class="control-group">
            <h3>导出设置</h3>
            <div class="parameter-row">
              <label for="imageSize">图像尺寸:</label>
              <div class="input-with-unit">
                <input type="number" id="imageSize" min="100" max="2000" step="10" value="1200">
                <span class="unit">px</span>
              </div>
              <div class="help-text">PNG图像的边长（正方形）</div>
            </div>
            <div class="parameter-row">
              <label for="resolution">分辨率:</label>
              <div class="input-with-unit">
                <input type="number" id="resolution" min="1" max="10" step="0.5" value="3">
                <span class="unit">倍</span>
              </div>
              <div class="help-text">PNG图像的缩放倍数</div>
            </div>
            <div class="parameter-row">
              <label for="smoothness">平滑度:</label>
              <div class="input-with-unit">
                <input type="number" id="smoothness" min="1" max="50000" step="100" value="10000">
                <span class="unit">点</span>
              </div>
              <div class="help-text">每圈的采样点数，值越大越平滑</div>
            </div>
          </div>

          <div class="control-group">
            <h3>电容设置</h3>
            <div class="parameter-row">
              <label>电容C</label>
              <div class="input-with-unit">
                <input type="number" id="capacitance" min="50" max="2000" step="1" value="220" />
                <span class="unit">pF</span>
              </div>
            </div>
          </div>
        </div>

        <!-- 生成线圈按钮已移除：参数修改后将自动保存并触发重绘 -->

        <div class="preview-container">
          <div class="canvas-wrapper">
            <div class="canvas-border">
              <canvas id="coilCanvas" width="600" height="600"></canvas>
            </div>
            <div class="coordinate-info" id="coordInfo">X: 0.0 mm, Y: 0.0 mm</div>
            <div class="status-bar" id="statusBar">就绪</div>
            <div class="loading" id="loading" style="display: none;">生成中...</div>
          </div>

          <div class="controls">
            <button class="btn-export-svg" id="exportSvg">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                <polyline points="7 10 12 15 17 10" />
                <line x1="12" y1="15" x2="12" y2="3" />
              </svg>
              导出SVG
            </button>
            <button class="btn-export-png" id="exportPng">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                <circle cx="8.5" cy="8.5" r="1.5" />
                <polyline points="21 15 16 10 5 21" />
              </svg>
              导出PNG
            </button>
          </div>

          <div class="info-panel" style="margin-top: 15px;">
            <div class="info-grid">
              <div class="info-item">
                <h4>外径</h4>
                <p id="outerRadius">-- mm</p>
              </div>
              <div class="info-item">
                <h4>导线总长度</h4>
                <p id="totalLength">-- mm</p>
              </div>
              <div class="info-item">
                <h4>导线面积</h4>
                <p id="wireArea">-- mm²</p>
              </div>
              <div class="info-item">
                <h4>最大半径</h4>
                <p id="maxRadius">-- mm</p>
              </div>
              <div class="info-item">
                <h4>电感</h4>
                <p id="inductance">-- μH</p>
              </div>
              <div class="info-item">
                <h4>谐振频率</h4>
                <p id="resonantFreq">--</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // 全局变量
      let canvas, ctx;
      let coilData = null;
      let autoGenerateTimer = null;
      let currentParams = {
        innerRadius: 3.5,
        spacing: 0.26,
        wireWidth: 0.15,
        turns: 17,
        // 默认电容（单位 pF）
        capacitance: 220,
        // 铜厚（oz），默认 PCB 常用 1 oz
        copperOz: 1,
        imageSize: 1200,
        resolution: 3,
        smoothness: 10000,
        showWire: true,
        transparentBg: true
      };

      // 初始化
      document.addEventListener('DOMContentLoaded', function () {
        canvas = document.getElementById('coilCanvas');
        ctx = canvas.getContext('2d', { alpha: true });

        // 尝试加载已保存的参数（若存在）
        loadSavedParams();

        // 设置初始值
        setInputValues();

        // 绑定事件
        bindEvents();

        // 初始生成
        generateCoil();
      });

      // 设置输入框初始值
      function setInputValues() {
        document.getElementById('innerRadius').value = currentParams.innerRadius;
        document.getElementById('spacing').value = currentParams.spacing;
        document.getElementById('wireWidth').value = currentParams.wireWidth;
        document.getElementById('turns').value = currentParams.turns;
        document.getElementById('imageSize').value = currentParams.imageSize;
        document.getElementById('resolution').value = currentParams.resolution;
        document.getElementById('smoothness').value = currentParams.smoothness;
        const capEl = document.getElementById('capacitance');
        if (capEl) capEl.value = currentParams.capacitance;
        const showWireEl = document.getElementById('showWire');
        if (showWireEl) showWireEl.checked = currentParams.showWire;
        const transparentEl = document.getElementById('transparentBg');
        if (transparentEl) transparentEl.checked = currentParams.transparentBg;
        // 若页面有铜厚输入（未添加控件时跳过）
        const copperEl = document.getElementById('copperOz');
        if (copperEl) copperEl.value = currentParams.copperOz;
      }

      // 绑定事件
      function bindEvents() {
        // 输入框变化
        document.querySelectorAll('input[type="number"]').forEach(input => {
          input.addEventListener('input', updateParam);
        });

        // 复选框变化
        document.querySelectorAll('input[type="checkbox"]').forEach(input => {
          input.addEventListener('change', updateParam);
        });

        // 按钮点击（生成按钮已移除，保留导出按钮绑定）
        document.getElementById('exportSvg').addEventListener('click', exportSvg);
        document.getElementById('exportPng').addEventListener('click', exportPng);

        // 鼠标移动显示坐标
        canvas.addEventListener('mousemove', showCoordinates);
      }

      // 更新参数
      function updateParam(e) {
        const id = e.target.id;
        let value;
        if (e.target.type === 'checkbox') {
          value = e.target.checked;
        } else {
          // 使用严格的数值解析与回退，避免空字符串或非法输入导致 NaN
          const raw = e.target.value;
          const parsed = parseFloat(raw);
          const min = parseFloat(e.target.min);
          const max = parseFloat(e.target.max);
          if (isNaN(parsed)) {
            // 回退为最小值或之前的参数值
            value = isFinite(min) ? min : currentParams[id] || 0;
            e.target.value = value;
          } else {
            value = parsed;
            if (!isNaN(min) && value < min) { value = min; e.target.value = value; }
            if (!isNaN(max) && value > max) { value = max; e.target.value = value; }
          }
        }

        currentParams[id] = value;
        // 自动保存最新参数（轻量写入 localStorage）
        try { saveParamsToStorage(false); } catch (err) { /* ignore */ }
        // 参数变化后自动生成（去抖）
        scheduleGenerate();
      }

      // 去抖调度自动生成，避免频繁重绘
      function scheduleGenerate(delay = 200) {
        if (autoGenerateTimer) clearTimeout(autoGenerateTimer);
        autoGenerateTimer = setTimeout(() => {
          try {
            generateCoil();
          } catch (err) {
            console.error('自动生成错误', err);
          }
        }, delay);
      }

      // 将当前参数保存到 localStorage
      function saveParamsToStorage(showNotice = false) {
        try {
          const serializable = Object.assign({}, currentParams);
          // 确保只保存基本类型
          localStorage.setItem('coil_last_params', JSON.stringify(serializable));
          if (showNotice) document.getElementById('statusBar').textContent = '参数已保存';
        } catch (err) {
          console.warn('保存参数失败', err);
          if (showNotice) document.getElementById('statusBar').textContent = '保存失败';
        }
      }

      // 从 localStorage 加载参数（仅覆盖已知字段）
      function loadSavedParams() {
        try {
          const raw = localStorage.getItem('coil_last_params');
          if (!raw) return;
          const obj = JSON.parse(raw);
          if (!obj || typeof obj !== 'object') return;
          // 仅接受已知字段，防止注入
          const keys = Object.keys(currentParams);
          let changed = false;
          keys.forEach(k => {
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
              const v = obj[k];
              // 简单类型校验
              if (typeof currentParams[k] === 'boolean') {
                currentParams[k] = !!v;
              } else if (typeof currentParams[k] === 'number') {
                const parsed = parseFloat(v);
                if (!isNaN(parsed)) currentParams[k] = parsed;
              } else {
                currentParams[k] = v;
              }
              changed = true;
            }
          });
          if (changed) document.getElementById('statusBar').textContent = '已加载上次保存参数';
        } catch (err) {
          console.warn('加载保存参数失败', err);
        }
      }

      // NOTE: 手动清除保存的接口已移除（改为只自动保存/加载）。如需清除请在控制台运行：localStorage.removeItem('coil_last_params')

      // 生成螺旋线数据（高精度）
      function generateSpiralData() {
        const { innerRadius, spacing, wireWidth, turns, smoothness } = currentParams;

        // 计算总点数和步长
        // 使 pointsPerTurn 与 totalPoints 为整数并有最小保护，避免 smoothness/turns 为小数或极小值导致数组越界或除以0
        const pointsPerTurn = Math.max(3, Math.round(smoothness));
        const totalPoints = Math.max(3, Math.round(turns * pointsPerTurn));
        if (pointsPerTurn < 3 || totalPoints < 3) {
          throw new Error('采样点太少：请增大圈数或平滑度（smoothness/turns）以获得足够采样点');
        }
        const dTheta = (2 * Math.PI) / pointsPerTurn;

        // 预分配数组
        const x = new Float64Array(totalPoints);
        const y = new Float64Array(totalPoints);
        const x_outer = new Float64Array(totalPoints);
        const y_outer = new Float64Array(totalPoints);
        const x_inner = new Float64Array(totalPoints);
        const y_inner = new Float64Array(totalPoints);

        let maxRadius = 0;
        let maxOuterRadius = 0;
        let totalLength = 0;

        // 生成螺旋线点
        // theta 计算：i 对应的角度按 pointsPerTurn 循环
        for (let i = 0; i < totalPoints; i++) {
          const theta = (i / pointsPerTurn) * 2 * Math.PI;
          const r = innerRadius + (spacing * theta) / (2 * Math.PI);

          if (r > maxRadius) maxRadius = r;

          // 中心线坐标
          x[i] = r * Math.cos(theta);
          // 使用数学坐标系：y 为正向上（不要取绝对值），绘制时把 y 取反以适配 Canvas 的向下为正
          y[i] = r * Math.sin(theta);

          // 计算法向量（用于偏移）
          const dx_dt = (spacing / (2 * Math.PI)) * Math.cos(theta) - r * Math.sin(theta);
          const dy_dt = (spacing / (2 * Math.PI)) * Math.sin(theta) + r * Math.cos(theta);
          const norm = Math.sqrt(dx_dt * dx_dt + dy_dt * dy_dt);
          const nx = -dy_dt / norm;
          const ny = dx_dt / norm;

          // 计算内外边界
          x_outer[i] = x[i] + (wireWidth / 2) * nx;
          y_outer[i] = y[i] + (wireWidth / 2) * ny;
          x_inner[i] = x[i] - (wireWidth / 2) * nx;
          y_inner[i] = y[i] - (wireWidth / 2) * ny;

          // 计算真实的外径（考虑偏移后点到原点的距离），用于精确的边界和缩放
          const outerRad = Math.sqrt(x_outer[i] * x_outer[i] + y_outer[i] * y_outer[i]);
          const innerRad = Math.sqrt(x_inner[i] * x_inner[i] + y_inner[i] * y_inner[i]);
          if (outerRad > maxOuterRadius) maxOuterRadius = outerRad;
          if (innerRad > maxOuterRadius) maxOuterRadius = innerRad;

          // 计算长度
          if (i > 0) {
            const dx = x[i] - x[i - 1];
            const dy = y[i] - y[i - 1];
            totalLength += Math.sqrt(dx * dx + dy * dy);
          }
        }

        // 计算导线面积
        const outerRadius = Math.max(maxOuterRadius, maxRadius + wireWidth / 2);
        const wireArea = totalLength * wireWidth;

        return {
          x, y,
          x_outer, y_outer,
          x_inner, y_inner,
          totalPoints,
          totalLength,
          maxRadius,
          outerRadius,
          wireArea
        };
      }

      // 生成线圈
      function generateCoil() {
        showLoading(true);
        document.getElementById('statusBar').textContent = '正在生成...';

        // 异步生成以避免阻塞UI
        setTimeout(() => {
          try {
            coilData = generateSpiralData();
            drawCoil();
            updateInfoPanel();
            document.getElementById('statusBar').textContent = '生成完成';
          } catch (error) {
            console.error('生成错误:', error);
            // 将错误信息展示到状态栏，方便用户调整参数
            document.getElementById('statusBar').textContent = `生成失败: ${error && error.message ? error.message : '未知错误'}`;
          } finally {
            showLoading(false);
          }
        }, 50);
      }

      // 绘制线圈（预览）
      function drawCoil() {
        if (!coilData) return;

        const { showWire, transparentBg } = currentParams;
        const canvasSize = 600;
        canvas.width = canvasSize;
        canvas.height = canvasSize;

        // 清空画布
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (!transparentBg) {
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // 计算缩放和平移
        const { maxRadius, outerRadius } = coilData;
        const padding = 20;
        // 使用 outerRadius（包含导线偏移）作为缩放基准，避免被裁剪
        const scale = (canvasSize - padding * 2) / (outerRadius * 2);
        const offsetX = canvasSize / 2;
        const offsetY = canvasSize / 2;

        // 保存状态
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        // 绘制导线区域
        if (showWire) {
          drawSmoothWire();
        }

        // 恢复状态
        ctx.restore();
      }

      // 绘制平滑的导线区域
      function drawSmoothWire() {
            const { x_outer, y_outer, x_inner, y_inner } = coilData;

            // 为预览进行降采样，避免在 smoothness 很大时产生过多绘制命令
            function decimate(xs, ys, maxPoints) {
              const n = xs.length;
              if (n <= maxPoints) {
                const pts = new Array(n);
                for (let i = 0; i < n; i++) pts[i] = { x: xs[i], y: -ys[i] };
                return pts;
              }
              const step = Math.max(1, Math.floor(n / maxPoints));
              const pts = [];
              for (let i = 0; i < n; i += step) pts.push({ x: xs[i], y: -ys[i] });
              // 确保末尾点包含
              if ((n - 1) % step !== 0) pts.push({ x: xs[n - 1], y: -ys[n - 1] });
              return pts;
            }

            // 控制预览点数上限（可调整），10000 对大多数浏览器为良好折中
            const maxPreviewPoints = 10000;
            const outerPts = decimate(x_outer, y_outer, maxPreviewPoints);
            const innerPts = decimate(x_inner, y_inner, maxPreviewPoints).reverse();

            // 如果进行了降采样，提示用户预览被简化（不会影响导出）
            if ((x_outer.length > outerPts.length) || (x_inner.length > innerPts.length)) {
              const bar = document.getElementById('statusBar');
              if (bar) bar.textContent = `预览已降采样显示 (${outerPts.length} pts)`;
            }

            ctx.beginPath();

            // 外边界（使用简化点做贝塞尔逼近）
            for (let i = 0; i < outerPts.length; i++) {
              const p = outerPts[i];
              if (i === 0) ctx.moveTo(p.x, p.y);
              else {
                const prev = outerPts[i - 1];
                const next = i < outerPts.length - 1 ? outerPts[i + 1] : p;
                const cp1x = (prev.x + p.x) / 2;
                const cp1y = (prev.y + p.y) / 2;
                const cp2x = (p.x + next.x) / 2;
                const cp2y = (p.y + next.y) / 2;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p.x, p.y);
              }
            }

            // 内边界（反向）
            for (let i = 0; i < innerPts.length; i++) {
              const p = innerPts[i];
              if (i === 0) ctx.lineTo(p.x, p.y);
              else {
                const prev = innerPts[i - 1];
                const next = i < innerPts.length - 1 ? innerPts[i + 1] : p;
                const cp1x = (prev.x + p.x) / 2;
                const cp1y = (prev.y + p.y) / 2;
                const cp2x = (p.x + next.x) / 2;
                const cp2y = (p.y + next.y) / 2;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p.x, p.y);
              }
            }

            ctx.closePath();
            ctx.fillStyle = 'black';
            ctx.fill();
      }

      // 更新信息面板
      function updateInfoPanel() {
        if (!coilData) return;

        // 外径显示为直径（直径 = 2 * 半径）
        document.getElementById('outerRadius').textContent = (coilData.outerRadius * 2).toFixed(2) + ' mm';
        document.getElementById('totalLength').textContent = coilData.totalLength.toFixed(1) + ' mm';
        document.getElementById('wireArea').textContent = coilData.wireArea.toFixed(2) + ' mm²';
        document.getElementById('maxRadius').textContent = coilData.maxRadius.toFixed(2) + ' mm';
        // 电感近似：使用 Mohan 等人的平面螺旋近似（适用于圆形/近圆形平面线圈）
        try {
          const mu0 = 4 * Math.PI * 1e-7; // H/m
          const N = parseFloat(currentParams.turns) || 0;
          // 外径/内径（mm）
          const Dout_mm = coilData.outerRadius * 2;
          const Din_mm = currentParams.innerRadius * 2;
          // Davg_m 应为平均半径（m），Mohan 公式中使用的是平均半径而非直径
          const Davg_m = ((Dout_mm + Din_mm) / 4) / 1000.0; // 平均半径，m
          const rho = (Dout_mm - Din_mm) / (Dout_mm + Din_mm || 1);
          let L_h = 0;
          if (Davg_m > 0 && N > 0 && rho > 0) {
            // Mohan-like formula: L ≈ μ0 * N^2 * Davg * ( ln(2.46/ρ) + 0.2*ρ^2 )
            const term = Math.log(2.46 / rho) + 0.2 * rho * rho;
            L_h = mu0 * N * N * Davg_m * term;
          }
          const L_uH = L_h * 1e6; // μH
          document.getElementById('inductance').textContent = (L_uH > 0 ? L_uH.toFixed(3) : '--') + ' μH';
          // 计算谐振频率：f = 1 / (2π sqrt(L * C))
          try {
            const C_pF = parseFloat(currentParams.capacitance) || 0;
            const C_F = C_pF * 1e-12; // pF -> F
            let fresText = '--';
            if (L_h > 0 && C_F > 0) {
              const fHz = 1 / (2 * Math.PI * Math.sqrt(L_h * C_F));
              if (fHz >= 1e6) fresText = (fHz / 1e6).toFixed(3) + ' MHz';
              else if (fHz >= 1e3) fresText = (fHz / 1e3).toFixed(3) + ' kHz';
              else fresText = fHz.toFixed(2) + ' Hz';
            }
            const rfEl = document.getElementById('resonantFreq');
            if (rfEl) rfEl.textContent = fresText;
          } catch (err) {
            const rfEl = document.getElementById('resonantFreq'); if (rfEl) rfEl.textContent = '--';
          }
        } catch (err) {
          document.getElementById('inductance').textContent = '-- μH';
        }
      }

      // 显示坐标
      function showCoordinates(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (!coilData) return;

        // 转换为世界坐标
        const { outerRadius } = coilData;
        const canvasSize = 600;
        const padding = 20;
        const scale = (canvasSize - padding * 2) / (outerRadius * 2);
        const offsetX = canvasSize / 2;
        const offsetY = canvasSize / 2;

        const worldX = (x - offsetX) / scale;
        const worldY = (offsetY - y) / scale; // 反转Y轴

        document.getElementById('coordInfo').textContent =
          `X: ${worldX.toFixed(3)} mm, Y: ${worldY.toFixed(3)} mm`;
      }

      // 导出SVG（用于PCB布线）
      function exportSvg() {
        if (!coilData) return;

        const { innerRadius, spacing, wireWidth, turns } = currentParams;
        const { x_outer, y_outer, x_inner, y_inner, totalPoints, outerRadius } = coilData;

        // 计算SVG尺寸和偏移
        const margin = wireWidth * 2;
        const svgSize = outerRadius * 2 + margin * 2;
        const center = svgSize / 2;

        // 生成更平滑的 SVG 路径：使用 Catmull-Rom -> Bezier 转换
        function decimatePoints(xs, ys, step) {
          const pts = [];
          for (let i = 0; i < xs.length; i += step) {
            pts.push({ x: xs[i] + center, y: center - ys[i] });
          }
          // 确保最后一个点包含
          if ((xs.length - 1) % step !== 0) {
            const i = xs.length - 1;
            pts.push({ x: xs[i] + center, y: center - ys[i] });
          }
          return pts;
        }

        function catmullRom2bezier(points, closed) {
          // 使用 centripetal Catmull-Rom (alpha = 0.5) 转换为三次 Bezier，减少尖刺/overshoot
          const d = [];
          const n = points.length;
          if (n < 2) return '';
          const alpha = 0.5;

          function dist(a, b) {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            return Math.sqrt(dx * dx + dy * dy);
          }

          function getPoint(i) {
            if (closed) return points[(i + n) % n];
            if (i < 0) return points[0];
            if (i >= n) return points[n - 1];
            return points[i];
          }

          d.push(`M ${points[0].x} ${points[0].y}`);

          const loopEnd = n - (closed ? 0 : 1);
          for (let i = 0; i < loopEnd; i++) {
            const p0 = getPoint(i - 1);
            const p1 = getPoint(i);
            const p2 = getPoint(i + 1);
            const p3 = getPoint(i + 2);

            const d01 = Math.pow(dist(p0, p1), alpha);
            const d12 = Math.pow(dist(p1, p2), alpha);
            const d23 = Math.pow(dist(p2, p3), alpha);

            // 计算控制点因子，避免除零
            const denom1 = (d01 + d12) || 1;
            const denom2 = (d12 + d23) || 1;

            const cp1x = p1.x + (p2.x - p0.x) * (d12 / (3 * denom1));
            const cp1y = p1.y + (p2.y - p0.y) * (d12 / (3 * denom1));

            const cp2x = p2.x - (p3.x - p1.x) * (d12 / (3 * denom2));
            const cp2y = p2.y - (p3.y - p1.y) * (d12 / (3 * denom2));

            d.push(`C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${p2.x} ${p2.y}`);
          }

          if (closed) d.push('Z');
          return d.join(' ');
        }

        // 控制导出采样密度：目标点数上限（越大越平滑，文件越大）
        const maxSvgPoints = 2000;
        const step = Math.max(1, Math.floor(totalPoints / maxSvgPoints));

        const outerPts = decimatePoints(x_outer, y_outer, step);
        const innerPts = decimatePoints(x_inner, y_inner, step).reverse();

        // 进一步处理：先平滑再简化点，减少噪点与尖刺
        function smoothPoints(pts, window = 3) {
          if (pts.length <= 2) return pts;
          const out = [];
          const half = Math.floor(window / 2);
          for (let i = 0; i < pts.length; i++) {
            let sx = 0, sy = 0, cnt = 0;
            for (let j = i - half; j <= i + half; j++) {
              const idx = (j + pts.length) % pts.length; // wrap for closed
              sx += pts[idx].x; sy += pts[idx].y; cnt++;
            }
            out.push({ x: sx / cnt, y: sy / cnt });
          }
          return out;
        }

        // Ramer-Douglas-Peucker 点简化（递归）
        function rdp(points, epsilon) {
          if (points.length < 3) return points.slice();
          // find point with max distance
          let dmax = 0; let index = 0;
          const end = points.length - 1;
          for (let i = 1; i < end; i++) {
            const d = pointLineDistance(points[i], points[0], points[end]);
            if (d > dmax) { index = i; dmax = d; }
          }
          if (dmax > epsilon) {
            const rec1 = rdp(points.slice(0, index + 1), epsilon);
            const rec2 = rdp(points.slice(index, points.length), epsilon);
            return rec1.slice(0, -1).concat(rec2);
          } else {
            return [points[0], points[end]];
          }
        }

        function pointLineDistance(p, a, b) {
          const A = p.x - a.x; const B = p.y - a.y;
          const C = b.x - a.x; const D = b.y - a.y;
          const dot = A * C + B * D;
          const len_sq = C * C + D * D;
          let param = (len_sq !== 0) ? dot / len_sq : -1;
          let xx, yy;
          if (param < 0) { xx = a.x; yy = a.y; }
          else if (param > 1) { xx = b.x; yy = b.y; }
          else { xx = a.x + param * C; yy = a.y + param * D; }
          const dx = p.x - xx; const dy = p.y - yy; return Math.sqrt(dx * dx + dy * dy);
        }

        // 平滑与简化（为闭合路径做环绕拷贝以避免端点效应）
        function preprocessPoints(pts) {
          if (pts.length <= 4) return pts;
          const sm = smoothPoints(pts, 5);
          // epsilon 相对于 svgSize 缩放，保证在不同尺寸下有合理阈值
          const eps = Math.max(0.5, svgSize * 0.0005);
          const simp = rdp(sm, eps);
          // 如果简化后点太少，退回平滑后的结果
          return simp.length >= 3 ? simp : sm;
        }

        // 导出预处理策略：
        // 'safe' - 仅降采样，不额外平滑/简化（保留原始拓扑，默认）
        // 'aggressive' - 先平滑再简化，可能消除残影但在极端参数下会改变轮廓
        const exportMode = 'safe';
        const outerPre = exportMode === 'aggressive' ? preprocessPoints(outerPts) : outerPts;
        const innerPre = exportMode === 'aggressive' ? preprocessPoints(innerPts) : innerPts;

        // 构建路径：外边界（闭合） + 内边界（反向闭合）
        let svgPath = '';
        if (outerPre.length >= 2) svgPath += catmullRom2bezier(outerPre, true);
        if (innerPre.length >= 2) svgPath += ' ' + catmullRom2bezier(innerPre, true);

        // 创建SVG文档
        const svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
      <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
      <svg width="${svgSize}mm" height="${svgSize}mm" viewBox="0 0 ${svgSize} ${svgSize}" 
           xmlns="http://www.w3.org/2000/svg" version="1.1">
          <path d="${svgPath}" fill="black" stroke="none" fill-rule="evenodd"/>
      </svg>`;

        // 下载SVG文件
        downloadFile(svg, `coil_r${innerRadius}_d${spacing}_w${wireWidth}_n${turns}.svg`, 'image/svg+xml');
        document.getElementById('statusBar').textContent = 'SVG已导出';
      }

      // 导出PNG（全尺寸高质量）
      function exportPng() {
        if (!coilData) return;

        showLoading(true);
        document.getElementById('statusBar').textContent = '正在导出PNG...';

        setTimeout(() => {
          try {
            const { imageSize, resolution, transparentBg } = currentParams;
            const finalSize = imageSize * resolution;

            // 创建临时canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = finalSize;
            tempCanvas.height = finalSize;
            const tempCtx = tempCanvas.getContext('2d');

            // 设置高质量渲染
            tempCtx.imageSmoothingEnabled = true;
            tempCtx.imageSmoothingQuality = 'high';

            // 设置背景
            if (!transparentBg) {
              tempCtx.fillStyle = 'white';
              tempCtx.fillRect(0, 0, finalSize, finalSize);
            }

            // 计算缩放和平移
            const { maxRadius } = coilData;
            const margin = currentParams.wireWidth * 2;
            const scale = (finalSize - margin * 2) / (maxRadius * 2 + currentParams.wireWidth);
            const offsetX = finalSize / 2;
            const offsetY = finalSize / 2;

            // 绘制到临时canvas
            tempCtx.save();
            tempCtx.translate(offsetX, offsetY);
            tempCtx.scale(scale, scale);

            // 绘制平滑导线区域
            drawSmoothWireToContext(tempCtx);

            tempCtx.restore();

            // 导出PNG
            tempCanvas.toBlob(blob => {
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              const { innerRadius, spacing, wireWidth, turns } = currentParams;
              a.download = `coil_r${innerRadius}_d${spacing}_w${wireWidth}_n${turns}_${imageSize}px.png`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);

              document.getElementById('statusBar').textContent = 'PNG已导出';
            }, 'image/png');

          } catch (error) {
            console.error('导出PNG错误:', error);
            document.getElementById('statusBar').textContent = '导出失败';
          } finally {
            showLoading(false);
          }
        }, 100);
      }

      // 绘制平滑导线到指定上下文
      function drawSmoothWireToContext(ctx) {
        if (!coilData) return;
        const { x_outer, y_outer, x_inner, y_inner } = coilData;

        // 使用与预览相同的降采样策略
        function decimate(xs, ys, maxPoints) {
          const n = xs.length;
          if (n <= maxPoints) {
            const pts = new Array(n);
            for (let i = 0; i < n; i++) pts[i] = { x: xs[i], y: -ys[i] };
            return pts;
          }
          const step = Math.max(1, Math.floor(n / maxPoints));
          const pts = [];
          for (let i = 0; i < n; i += step) pts.push({ x: xs[i], y: -ys[i] });
          if ((n - 1) % step !== 0) pts.push({ x: xs[n - 1], y: -ys[n - 1] });
          return pts;
        }

        const maxPreviewPoints = 10000;
        const outerPts = decimate(x_outer, y_outer, maxPreviewPoints);
        const innerPts = decimate(x_inner, y_inner, maxPreviewPoints).reverse();

        ctx.beginPath();
        for (let i = 0; i < outerPts.length; i++) {
          const p = outerPts[i];
          if (i === 0) ctx.moveTo(p.x, p.y);
          else {
            const prev = outerPts[i - 1];
            const next = i < outerPts.length - 1 ? outerPts[i + 1] : p;
            const cp1x = prev.x + (p.x - prev.x) * 0.5;
            const cp1y = prev.y + (p.y - prev.y) * 0.5;
            const cp2x = p.x + (next.x - p.x) * 0.5;
            const cp2y = p.y + (next.y - p.y) * 0.5;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p.x, p.y);
          }
        }

        for (let i = 0; i < innerPts.length; i++) {
          const p = innerPts[i];
          if (i === 0) ctx.lineTo(p.x, p.y);
          else {
            const prev = innerPts[i - 1];
            const next = i < innerPts.length - 1 ? innerPts[i + 1] : p;
            const cp1x = prev.x + (p.x - prev.x) * 0.5;
            const cp1y = prev.y + (p.y - prev.y) * 0.5;
            const cp2x = p.x + (next.x - p.x) * 0.5;
            const cp2y = p.y + (next.y - p.y) * 0.5;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p.x, p.y);
          }
        }

        ctx.closePath();
        ctx.fillStyle = 'black';
        ctx.fill();
      }

      // 通用文件下载函数
      function downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // 显示/隐藏加载状态
      function showLoading(show) {
        document.getElementById('loading').style.display = show ? 'block' : 'none';
      }
    </script>
  </body>

</html>